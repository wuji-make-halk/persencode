1. 对面向对象 的理解。
答:(1) 所有的事物都可抽象成不同的类,而具体事物就是这些类的一个对象。编程时可以 将对象想象为一种新型变量,它保存着数据,而且还可以对自身数据进行操作。
(2) 程序是由很多对象组合而成的。通过消息传递,各对象知道自己应该做些什么。如果需 要让对象做一些事情,则需向该对象发出一条行为指令。
(3) 要为每个对象分配存储空间。对象可以容纳其他对象,即通过封装现有的对象,可以产 生新型对象。因此,尽管对象的概念非常简单 ,但是经过封装以后却可以在程序中达到任意 的高复杂程度。
(4) 每个对象都属于特定的类。根据语法,每个对象都是某个 “类”的一个“实例”。一个 类最重要的特征是 “能将什么消息发给它 ”,即类有哪些行为。
综上所述:面向对象可以理解成对待每一个问题 ,都是首先要确定这个问题由几个部分 组成,而每一个部分其实就是一个对象。然后再分别设计这些对象,最后得到整个程序 。传 统的程序设计多是基于功能的思想来进行考虑和设计的 ,而面向对象的程序设计则是基于对 象的角度来考虑问题。这样做能够使得程序更加简洁、清晰。
2. 面向过程和面向对象有什么区别 ? 答:面向过程就是指分析出解决问题所需要的步骤,然后用函数把这些步骤一步一步实现 , 使用的时候一个一个依次调用就可以了。 面向对象是把构成问题的事务分解成各个对象,建立对象的目的不是为了完成一个步骤 ,而 是为了描述某个事物在整个解决问题步骤中的行为。
3. 对象都具有的二方面特征是什么?分别是什么含义? 答:对象都具有的特征是静态特征和动态特征 。静态特征是指能描述对象的一些属性 ,动态 特征是指对象表现出来的行为 。
4. 在头文件中进行类的声明,在对应的实现文件中进行类的定义有什么意义? 答:这样可以提高编译效率 ,因为分开的话只需要编译一次 ,生成对应的.obj 文件后,再次 应用该类的地方,这个类就不会被再次编译,从而大大提高了效率。
5. 在类的内部定义成员函数的函数体,这种函数会具备 哪种属性? 答:这种函数会自动为内联函数 ,这种函数在函数调用的地方在 编译阶段都会进行代码替换 。
6. 成员函数通过什么来区分不同对象的成员数据?为什么它能够区分? 答:通过 this 指针来区分的,因为它指向的是对象的首地址。
7. C++编译器自动为类产生的四个缺省函数是什么? 答:默认构造函数,拷贝构造函数,析构函数,赋值函数。
8. 拷贝构造函数在哪几种情况下会被调用?
答:(1) 当用类的一个对象去初始化该类的另一个对象时;
(2) 如果函数的形参是类的对象,调用函数进行形参和实参结合时; (3) 如果函数的返回值是类对象,函数调用完成返回时。
9. 构造函数与普通函数相比在形式上有什么不同?(从构造函数的作用 ,它的声明形式来
分析)
答:构造函数是类的一种特殊成员函数 ,一般情况下,它是专门用来初始化对象成员变量的 。 构造函数的名字必须与类名相同,它不具有任何类型,不返回任何值。
10. 什么时候必须重写拷贝构造函数? 答:当构造函数涉及到动态存储分配空间时,要自己写拷贝构造函数,并且要深拷贝。
11. 构造函数的调用顺序是什么? 答:(1) 先调用基类构造函数;
(2) 按声明顺序初始化数据成员; (3) 最后调用自己的构造函数。
12. 哪几种情况必须用到初始化成员列表? 答:(1) 类有常量成员;
(2) 类有对象成员,而该对象没有无参构造函数; (3) 类有引用成员。
13. 什么是常对象? 答:常对象是指在任何场合都不能对其成员的值进行修改的对象。
14. 静态函数存在的意义?
答:静态私有成员在类外不能被访问 ,可通过类的静态成员函数来访问 ;当类的构造函数是 私有的时,不像普通类那样实例化自己,只能通过静态成员函数来调用构造函数。
15. 在类外有什么办法可以访问类的非公有成员? 答:友元,继承,公有成员函数。
16. 什么叫抽象类? 答:不用来定义对象而只作为一种基本类型用作继承的类。
17. 运算符重载的意义? 答:为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致 。
18. 不允许重载的 5 个运算符是哪些? 答:(1) .*(成员指针访问运算符)
(2) ::(作用域运算符) (3) sizeof(长度运算符) (4) ?:(条件运算符)
(5) .(成员访问运算符)
19. 运算符重载的三种方式? 答:普通函数,友元函数,类成员函数。
20. 流运算符为什么不能通过类的成员函数重载?一般怎么解决?
答:因为通过类的成员函数重载必须运算符的第一个是自己 ,而对流运算的重载要求第一个 参数是流对象。一般通过友元来解决。
21. 赋值运算符和拷贝构造函数的区别与联系? 答:相同点:都是将一个对象 copy 到另一个中去。
不同点:拷贝构造函数涉及到要新建立一个对象。
22. 在哪种情况下要调用该类的析构函数? 答:对象生命周期结束时。
23. 对象间是怎样实现数据共享的?
答:通过类的静态成员变量来实现的 。静态成员变量占有自己独立的空间不为某个对象所私 有。
24. 友元关系有什么特性? 答:单向的,非传递的,不能继承的。
25. 对对象成员进行初始化的次序是什么?
答:它的次序完全不受它们在初始化 列表中次序的影响,只有成员对象在类中声明的次序来 决定的。
26. sizeof 和 strlen 的区别有哪些?
答:(1) sizeof 是一个操作符,strlen 是库函数;
(2) sizeof 的参数可以是数据的类型,也可以是变量,而 strlen 只能以结尾为 '\0'的字符 串做参数;
(3) 编译器在编译的时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算 出来。并且 sizeof 计算的是数据类型占内存的大小,而 strlen 计算的是字符串实际的长度 ;
(4) 数组做 sizeof 的参数不退化,传递给 strlen 就退化为指针了。
27. typedef 和 define 有什么区别?
答:(1) 用法不同:typedef 用来定义一种数据类型的别名 ,增强程序的可读性。define 主要 用来定义常量,以及书写复杂、使用频繁的宏;
(2) 执行时间不同:typedef 是编译过程的一部分,有类型检查的功能。define 是宏定义, 是预编译的部分,其发生在编译之前,只是简单地进行字符串的替换,不进行类型的检查 ;
(3) 作用域不用:typedef 有作用域限定。define 不受作用域约束,只要是在 define 声明 后的引用都是正确的;
(4) 对指针的操作不同:typedef 和 define 定义的指针有很大的区别。
28. const char *p;与 char * const p;的区别
答:如果 const 位于星号的左侧,则 const 就是用来修饰指针所指向的变量,即指针指向常 量;如果 const 位于星号的右侧,const 就是修饰指针本身,即指针本身是常量。
29. 是不是一个父类写了一个 virtual 函数,如果子类覆盖它的函数不加 virtual,也能实现多 态?
答:virtual 修饰符会被隐形继承的。 virtual 可加可不加,子类覆盖它的函数不加 virtual,也 能实现多态。
30. 函数重载是什么意思?它与虚函数的概念有什么区别? 答:函数重载是一个同名函数完成不同的功能 ,编译器在编译阶段通过函数参数个数 、参数 类型不同来区分该调用哪一个函数 ,即实现的是静态的多态性 。但是记住:不能仅仅通过函 数返回值不同来实现函数重载。而虚函数实现的是在基类中通过使用关键字 virtual 来声明 一个函数为虚函数 ,含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之 上进行扩展,系统只能在运行阶段才能动态决定该调用哪一个函数 ,所以实现的是动态的多 态性。它体现的是一个纵向的概念,也即在基类和派生类间实现。
31. 构造函数和析构函数是否可以被重载 ,为什么?
答:构造函数可以被重载 ,析构函数不可以被重载 。因为构造函数可以有多个且可以带参数 , 而析构函数只能有一个,且不能带参数。
32. 如何定义和实现一个类的成员函数为回调函数? 答:所谓回调函数,就是预先在系统中对函数进行注册,让系统知道这个函数的存在 ,以后, 当某个事件发生时 ,再调用这个函数对事件进行响应 。定义一个类的成员函数时在该函数前 加 CALLBACK 即将其定义为回调函数,函数的实现和普通成员函数没有区别
33. 虚函数是怎么实现的? 答:简单来说 是使用了虚函数表 。
34. 抽象类不会产生实例,所以不需要有构造函数。 答:错
35. 从一个模板类可以派生新的模板类,也可以派生非模板类。 答:对
36. delete 与 delete []区别:
答:delete 只会调用一次析构函数,而 delete[]会调用每一个成员的析构函数。
37. 继承优缺点。 答:优点:
(1) 继承是在编译时刻静态定义的,且可直接使用;
(2) 继承可以较方便地改变父类的实现。
缺点:
(1) 因为继承在编译时刻就定义了,所以无法在运行时刻改变从父类继承的实现 ;
(2) 父类通常至少定义了子类的部分行为,父类的任何改变都可能影响子类的行
为;
(3) 如果继承下来的实现不适合解决新的问题,则父类必须重写或被其他更适合的 类替换。这种依赖关系限制了灵活性并最终限制了复用性。
38. 解释堆和栈的区别。
答:栈:—般由编译器自动分配释放,存放函数的参数值,局部变量的值等。 堆:一般由程序员分配释放,若程序员不释放,程序结束时可能由 OS 回收。
39. 一个类的构造函数和析构函数什么时候被调用 ,是否需要手工调用? 答:构造函数在创建类对象的时候被自动调用 ,析构函数在类对象生命期结束时 ,由系统自 动调用。
40. 何时需要预编译 ?
答:(1) 总是使用不经常改动的大型代码体。
(2) 程序由多个模块组成,所有模块都使用一组标准的包含文件和相同的编译选项 。在 这种情况下,可以将所有包含文件预编译为一个预编译头。
41. 虚函数与普通成员函数的区别?内联函数和构造函数能否为虚函数? 答:区别:虚函数有 virtual 关键字,有虚拟指针和虚函数表 ,虚拟指针就是虚函数的接口 , 而普通成员函数没有。内联函数和构造函数不能为虚函数。
42. 构造函数和析构函数的调用顺序 ?析构函数为什么要虚拟 ? 答:构造函数的调用顺序:基类构造函数 —>对象成员构造函数—>派生类构造函数;析构 函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底,造成内存泄漏。
43. C++中类型为 private 的成员变量可以由哪些函数访问 ? 答:只可以由本类中的成员函数和友员函数访问 。
44. 请说出类中 private,protect,public 三种访问限制类型的区别
答:private 是私有类型,只有本类中的成员函数访问 ;protect 是保护型的,本类和继承类可 以访问;public 是公有类型,任何类都可以访问 。
45. 类中成员变量怎么进行初始化?
答:可以通过构造函数的 成员初始化列表或构造函数的函数体实现。
46. 引用与指针有什么区别?
答:(1) 引用必须被初始化,但是不分配存储空间。指针可以在声明时不初始化,在初始化 的时候需要分配存储空间;
(2) 引用初始化以后不能被改变,指针可以改变所指的对象 ; (3) 不存在指向空值的引用,但是存在指向空值的指针。
47. 描述实时系统的基本特性 答:在特定时间内完成特定的任务,实时性与可靠性。
48. 全局变量和局部变量在内存中是否有区别?如果有,是什么区别? 答:全局变量储存在静态数据区,局部变量在堆栈中。
49. 如何引用一个已经定义过的全局变量?
答:可以用引用头文件的方式 ,也可以用 extern 关键字。如果用引用头文件方式来引用某个
在头文件中声明的全局变 量,假定你将那个变量写错了,那么在编译期间会报错 ,如果你用 extern 方式引用时,假定你犯了同样的错误,那么在编译期间不会报错,而在连接期间报错。
50. C++函数中值的传递方式 答:有三种方式:值传递、指针传递、引用传递
51. extern "C"有什么作用?
答:extern "C"是由 C++提供的一个连接交换指定符号,用于告诉 C++这段代码是 C 函数。 这是因为 C++编译后库中函数名会变得很长 ,与 C 生成的不一致,造成 C++不能直接调用 C 函数,加上 extren "C"后,C++就能直接调用 C 函数了。
extern "C"主要使用正规 DLL 函数的引用和导出和在 C++包含 C 函数或 C 头文件时使 用。使用时在前面加上 extern "C"关键字即可。
52. 用什么函数开启新进程、线程。 答:进程:CreateProcess 等
线程:CreateThread/AfxBeginThread 等
53. SendMessage 和 PostMessage 有什么区别?
答: SendMessage 是阻塞的,等消息被处理后,代码才能走到
PostMessage 是非阻塞的,不管消息是否已被处理,代码马上走到 PostMessage 的下一行。
54. CMemoryState 主要功能是什么 答:查看内存使用情况,解决内存泄露问题。
55. 处理器标识#error 的目的是什么? 答:编译时输出一条错误信息,并中止继续编译。
56. 在定义一个宏的时候要注意什么? 答:定义部分的每个形参和整个表达式都必须用括号括起来,以避免不可预料的错误发生 。
57. 系统会自动打开和关闭的 3 个标准的文件是? 答:(1) 标准输入----键盘---stdin
(2) 标准输出----显示器---stdout
(3) 标准出错输出----显示器---stderr
58. strcpy()和 memcpy()的区别?
答:strcpy()和memcpy()都可以用来拷贝字符串, strcpy()拷贝以'\0'结束,但 memcpy()必须 指定拷贝的长度。
59. 说明 define 和 const 在语法和含义上有什么不同?
答:(1) #define 是 C 语法中定义符号变量的方法 ,符号常量只是用来表达一个值 ,在编译阶 段符号就被值替换了,它没有类型;
(2) const 是 C++语法中定义常量的方法,常量具有变量特性,它具有类型,内存中存在 以它命名的存储单元,可以用 sizeof 测出长度。
SendMessage 的下一行。
60. 说出字符常量和字符串常量的区别,并使用运算符 sizeof 计算有什么不用? 答:字符常量是指单个字符,字符串常量以'\0'结束,使用运算符 sizeof 计算多占一字节的存 储空间。
61. 简述全局变量的优缺点?
答:全局变量也称为外部变量 ,它是在函数外部定义的变量 ,它属于一个源程序文件 ,它保 存上一次被修改后的值,便于数据共享,但不方便管理,易引起意想不到的错误。
62. 总结 static 的应用和作用?
答:(1) 函数体内 static 变量的作用范围为该函数体,不同于 auto 变量,该变量的内存只被 分配一次,因此其值在下次调用时仍维持上次的值;
(2) 在模块内的 static 全局变量可以被模块内所 有函数访问,但不能被模块外其它函数 访问;
(3) 在模块内的 static 函数只可被这一模块内的其它函数调用,这个函数的使用范围被 限制在声明它的模块内;
(4) 在类中的 static 成员变量属于整个类,对类的所有对象只有一份拷贝;
(5) 在类中的 static 成员函数属于整个类,这个函数不接收 this 指针,因而只能访问类 的 static 成员变量。
63. 总结 const 的应用和作用?
答:(1) 欲阻止一个变量被改变 ,可以使用 const 关键字。在定义该 const 变量时,通常需要 对它进行初始化,因为以后就没有机会再去改变它;
(2) 对指针来说,可以指定指针本身为 const,也可以指定指针所指的数据为 const,或 二者同时指定为 const;
(3) 在一个函数声明中,const 可以修饰形参,表明它是一个输入参数,在函数内部不能 改变其值;
(4) 对于类的成员函数,若指定其为 const 类型,则表明其是一个常函数,不能修改类 的成员变量;
(5) 对于类的成员函数,有时候必须指定其返回值为 const 类型,以使得其返回值不为 “左值”。
64. 什么是指针?谈谈你对指针的理解?
答:指针是一个变量 ,该变量专门存放内存地址 ;指针变量的类型取决于其指向的数据类型 ; 指针变量的特点是它可以访问所指向的内存。
65. 什么是常指针,什么是指向常变量的指针? 答:常指针的含义是该指针所指向的地址不能变 ,但该地址所指向的内容可以变化 ,使用常 指针可以保证我们的指针不能指向其它的变量 。
指向常变量的指针是 指指针变量指向的地址可以变化 ,可以指向其它的变量 ,但是它所 指的内容不可以被修改。
66. 函数指针和指针函数的区别? 答:函数指针是指指向一个函数入口的指针;指针函数是指函数的返回值是一个指针类型 。
67. 简述 Debug 版本和 Release 版本的区别?
答:Debug 版本是调试版本,Release 版本是发布给用户的最终非调试的版本,
68. 指针的几种典型应用情况?
答:int *p[n]; int (*p)[n];
int *p(); int (*p)();
// 指针数组,每个元素均为指向整型数据的指针。
// p 为指向一维数组的指针,这个一维数组有 n 个整型数据。 // 指针函数,指针指向返回的值。
// 函数指针,p 为指向函数的指针。
69. struct 和 union 的区别?
答:(1) 结构和联合都是由多个不同的数据类型成员组成 ,但在任何同一时刻,联合中只存 放了一个被选中的成员(所有成员共用一块地址空间 ),而结构的所有成员都存在(不同成 员的存放地址不同 )。
(2) 对于联合的不同成员赋值,将会对其它成员重写,原来成员的值就不存在了,而对 于结构的不同成员赋值是互不影响的。
70. 简述枚举类型? 答:枚举方便一次定义一组常量,使用起来很方便 。
71. ASSERT()的作用? 答:ASSERT()是一个调试程序时经常使用的宏,在程序运行时它计算括号内的表达式,如 果表达式为 FALSE(0),程序将报告错误,并终止执行。如果表达式不为 0,则继续执行后 面的语句。这个宏通常用来判断程序中是否出现了明显非法的数据 ,如果出现了,终止程序 以免导致严重后果,同时也便于查找错误。
72. 类的声明和实现分开的好处? 答:起保护作用 和提高编译的效率。
73. Windows 消息系统由哪几部分构成? 答:由一下 3 部分组成:
(1) 消息队列:操作系统负责为进程维护一个消息队列 ,程序运行时不断从该消息队列 中获取消息、处理消息;
(2) 消息循环:应用程序通过消息循环不断获取消息、处理消息 ;
(3) 消息处理:消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行
处理。
74. 什么是消息映射?
答:MFC 消息映射机制的具体实现方法是:在每个能接收和处理消息的类中,定义一个消 息和消息函数对照表 ,即消息映射表 。在消息映射表中 ,消息与对应的消息处理函数指针是 成对出现的 。某个类能处理的所有消息及其对应的消息处理函数的地址都列在这个类对应的 静态表中。当有消息需要处理时,程序只要搜索该消息静态表,查看表中是否含有该消息 , 就可知道该类能否处理此消息 。如果能处理该消息 ,则同样依照静态表很容易找到并调用对 应的消息处理函数 。
75. UDP 和 TCP 的区别是什么?
答:TCP 全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
UDP 全称为用户报文协议,它可以提供 无连接的、不可靠的、点到多点的通信。 76. 进程间主要的通讯方式?
答:信号量,管道,消息,共享内存 。
77. 构成 Win32 API 函数的三个动态链接库是什么? 答:内核库,用户界面管理库,图形设备界面库。
78. 创建一个窗口的步骤是? 答:设计一个窗口类->注册窗口类->创建窗口->显示及更新窗口。
79. 模态对话框和非模态对话框有什么区别?
答:(1) 调用规则不同:前者是用 DoModal()调用,后者通过属性和 ShowWindow()来显示。
(2) 模态对话框在没有关闭前用户不能进行其他操作,而非模态对话框可以。
(3) 非模态对话框创建时必须编写自己的共有构造函数,还要调用 Create()函数。
80. 从 EDIT 框中取出数据给关联的变量 ,已经把关联的变量的数据显示在 EDIT 框上的函 数是什么?
答:UpdateData(TRUE), Updatedata(FALSE).
81. 简单介绍 GDI?
答:GDI 是 Graphics Device Interface 的缩写,译为:图形设备接口;是一个在 Windows 应 用程序中执行与设备无关的函数库,这些函数在不同的输出设备上产生图形以及文字输出 。
82. Windows 消息分为几类?并对各类做简单描述。
答:(1) 窗口消息:与窗口相关的消息,除 WM_COMMAND 之外的所有以 WM_开头的消 息;
(2) 命令消息:用于处理用户请求,以 WM_COMMAND 表示的消息; (3) 控件通知消息:统一由 WM_NOTIFY 表示的消息;
(4) 用户自定义消息。
83. 如何自定义消息?
答:使用 WM_USER 和 WM_APP 两个宏来自定义消息。
84. 简述 Visual C++、Win32 API 和 MFC 之间的关系?
答:(1) Visual C+是一个以 C++程序设计语言为基础的、集成的、可视化的编程环境 。
(2) Win32 API 是 32 位 Windows 操作系统以 C/C++形式提供的一组应用程序接口 。 (3) MFC 是对 Win32 API 的封装,简化了开发过程。
85. 怎样消除多重继承中的二义性? 答:(1) 成员限定符;(2) 虚基类。
86. 什么叫静态关联,什么叫动态关联 答:在多态中,如果程序在编译阶段就能确定实际执行动作 ,则称静态关联;如果等到程序 运行才能确定叫动态关联。
87. 多态的两个必要条件
答:(1) 一个基类的指针或引用指向一个派生类对象;(2) 虚函数。
88. 什么叫智能指针?
答:当一个类中,存在一个指向另一个类对象的指针时 ,对指针运算符进行重载 ,那么当前 类对象可以通过指针像调用自身成员一样调用另一个类的成员。
89. 什么时候需要用虚析构函数?
答:当基类指针指向用 new 运算符生成的派生类对象时,delete 基类指针时,派生类部分没 有释放掉而造成释放不彻底现象,需要虚析构函数。
90. 派生新类的过程要经历三个步骤 答:(1) 吸收基类成员;
(2) 改造基类成员; (3) 添加新成员。
91. memset,memcpy 的区别
答:memset 用来对一段内存空间全部设置为某个字符,一般用在对定义的字符串进行初始 化为'\0'。
memcpy 用来做内存拷贝,你可以拿它拷贝任何数据类型的对象 ,可以指定拷贝的数据 长度。
92. 在 C++程序中调用被 C 编译器编译后的函数,为什么要加 extern "C"? 答:C++语言支持函数重载,C 语言不支持函数重载。函数被 C++编译后在库中的名字与 C 语言的不同。假设某个函数的原型为:void foo(int x, int y);该函数被 C 编译器编译后在库中 的名字为_foo,而 C++编译器则会产生像_foo_int_int 之类的名字。C++提供了 C 连接交换指 定符号 extern "C"来解决名字匹配问题。
93. 一个单向链表 ,不知道头节点 ,一个指针指向其中的一个节点 ,问如何删除这个指针指 向的节点?
答:将这个指针指向的 next 节点值 copy 到本节点,将 next 指向 next->next,并随后删除原 next 指向的节点。
94. 头文件的作用是什么 ?
答:(1) 通过头文件来调用库功能。在很多场合,源代码不便(或不准)向用户公布,只要 向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能 , 而不必关心接口 是怎么实现的。编译器会从库中提取相应的代码。
(2) 头文件能加强类型安全检查。如果某个接口被实现或被使用时,其方式与头文件中 的声明不一致,编译器就会指出错误,这一简单的规则能大大减轻程序员调试 、改错的负担。
95. 子类析构时要调用父类的析构函数吗? 答:要。析构函数调用的次序是先派生类的析构后基类的析构 ,也就是说在基类的的析构调 用的时候,派生类的信息已经全部销毁了 。
96. C 和 C++有什么不同?
答:从机制上:C 是面向过程的(但 C 也可以编写面向对象的程序 );C++是面向对象的, 提供了类。但是,C++编写面向对象的程序比 C 容易。
从适用的方向:C 适合要求代码体积小、效率高的场合,如嵌入式;C++适合更上层的、 复杂的;linux 核心大部分是 C 写的,因为它是系统软件,效率要求极高。
从名称上也可以看出, C++比 C 多了+,说明 C++是 C 的超集;那为什么不叫 C+而叫 C++呢,是因为 C++对 C 来说扩充的东西太多了 ,所以就在 C 后面放上两个+,于是就成了 C++。
C 语言是结构化编程语言, C++是面向对象编程语言。 C++侧重于对象而不是过程,侧 重于类的设计而不是逻辑的设计。
97. 动态连接库的两种方式 ? 答:调用一个 DLL 中的函数有两种方法:
(1) 载入时动态链接(load-time dynamic linking),模块非常明确地调用某个导出函数, 使得他们就像本地函数一样。这需要链接时链接那些函数所在 DLL的导入库,导入库向系 统提供了载入 DLL 时所需的信息及 DLL 函数定位。
(2) 运行时动态链接(run-time dynamic linking),运行时可以通过 LoadLibrary 或 LoadLibraryEx 函数载入 DLL。DLL 载入后,模块可以通过调用 GetProcAddress 获取 DLL 函数的出口地址, 然后就可以通过返回的函数指针调用 DLL 函数。如此即可避免导入库文件。
